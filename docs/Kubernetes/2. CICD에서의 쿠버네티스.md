### ✅ 쿠버네티스를 개발자가 사용하는 실제 상황은?

- 수동으로 서버에 접속해서 컨테이너 실행, 설정, 모니터링 하는 것이 아니라  
    → **CI/CD 파이프라인에 쿠버네티스를 연결하여 자동화**합니다.
    
- 예를 들어, GitHub에 코드를 푸시하면  
    → Jenkins나 GitHub Actions에서 CI 빌드 →  
    → Docker 이미지 생성 후  
    → 쿠버네티스 클러스터에 자동 배포됩니다.
    

---

### ✅ 왜 초보 개발자에게는 MSA보다 DevOps 관점이 더 적합한가?

- MSA는 설계 구조부터 진입장벽이 높고, 분산 트랜잭션, 서비스 디스커버리 등 복잡한 개념을 요구합니다.
    
- 반면 **DevOps 환경에서의 쿠버네티스는 '자동 배포 플랫폼'으로 접근할 수 있어** 상대적으로 단순하고 실용적입니다.
    
- 초보자도 “내 코드가 어떻게 자동으로 배포되는지” 흐름을 쿠버네티스를 통해 쉽게 이해할 수 있습니다.
    

---

### ✅ 이번 발표에서는?

> 쿠버네티스를 **DevOps 자동화 환경(CI/CD)**을 기준으로 설명하고,  
> 개발자가 쿠버네티스를 통해 **어떻게 애플리케이션을 자동으로 운영할 수 있는지**에 중점을 두겠습니다.


개발자가 코드를 작성하고, 이를 배포하는 전체 흐름에서 **Kubernetes가 어떤 역할을 하는지**를 아래 그림을 통해 쉽게 이해할 수 있습니다.

![[Pasted image 20250505122306.png]]

이 그림에서 보듯이, **쿠버네티스는 배포 단계에서 컨테이너를 자동으로 생성하고, 최신 이미지를 적용하여 실행 환경에 반영하는 핵심 역할**을 맡고 있습니다.

즉, 개발자는 단지 코드를 작성하고 Git에 푸시하기만 하면,  
CI/CD 파이프라인을 거쳐 쿠버네티스가 **자동으로 배포, 스케일링, 관리까지 처리해주는 구조**라고 이해할 수 있습니다.

그렇다면, **쿠버네티스는 내부적으로 어떻게 컨테이너를 생성하고 이미지를 받아오는 걸까요?**
아래 그림을 통해 쿠버네티스 내부 구조를 이해할 수 있습니다.

![[Pasted image 20250505122715.png]]

### ✅ 결론

현재 쿠버네티스는 **`kubelet`이 CRI-Plugin 또는 `cri-dockerd`와 통신하여 컨테이너를 생성하고 관리**하는 구조로 동작합니다.  
이를 통해 쿠버네티스는 **다양한 컨테이너 런타임(containerd, CRI-O, Docker 등)**과 연동 가능하며, 컨테이너 생성과 이미지 관리를 유연하게 수행할 수 있습니다.